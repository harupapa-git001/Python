'''
    ４．ジェネレータ
    
    ジェネレータは「何回も要素を返却できる関数」のようなモノです。
    
    関数と違って"yield"で要素を返却します。
    
    が、こんな説明をしても大半の人は「？？？」となると思うので、まずは簡単な例を見てみましょう。

'''
#ジェネレータ

#ジェネレータの定義

def generator():
    yield 0
    
    yield 1
    
    yield 2
    
for g in generator():
    print(g)    #0、1、2と順に表示

'''
    とてもシンプルなジェネレータを用意してみました。
    
    見ての通りジェネレータは関数として定義しますが、使い方を見ると前節で説明したイテレータによく似ていることに気が付くと思います。
    
    この例では「for文がジェネレータから要素を取り出そうとするたびに関数内のyieldが順に呼び出されている」と考えてください。
    
    なお、イテレータでは「StopIteration例外の発生＝ループの終了」でしたが、ジェネレータでは「これ以上呼び出すyieldが無い＝ループの終了」となります。
    
    （もちろん両者ともbreakでもループが終了します）ジェネレータは関数として定義するので通常の関数と同じように引数を受け取れますし、自由に処理を記述することもできます。
    
    具体例を見てみましょう。

'''
#引数を受け取るジェネレータ

def count_up(start):
    x = start
    
    while True:
        yield x

        x += 1
        
for c in count_up(0):
    print(c)    #0、1、2と順に表示
    
    if c >= 2:
        break

for c in count_up(10):
    print(c)    #10、11、12と順に表示
    
    if c >= 12:
        break

'''
    次に、なぜfor文でジェネレータがイテレータと同じように振る舞えるのか種明かしをします。
    
    実は、ジェネレータは「関数呼び出しされるとイテレータオブジェクトとなる」のです。
    
    イテレータオブジェクトになると言うことは、next関数で順に値が取り出せると言うことです。
    
    これも具体例を見てみましょう。

'''

'''ex2
#ジェネレータとイテレータ

def generator():
    yield 0
    
    yield 1
    
    yield 2
    
gen =generator()

print(next(gen))

print(next(gen))

print(next(gen))

print(next(gen))

'''

'''
    例の通り、関数呼び出しされたジェネレータ（gen）はイテレータと同じ動きをしています。
    
    実行結果を見れば、next関数を呼び出すたびに"yield"が実行され、これ以上実行する"yield"が無い場合はStopIterationが発生していることがわかると思います。
    
    ジェネレータがfor文に渡されると最初に「関数として実行される」ため、結果としてイテレータとしてfor文で処理されているのです。
    
    これが「for文でジェネレータがイテレータと同じように振る舞える」カラクリです。
    
    続いて「ジェネレータ式」についても覚えておきましょう。
    
    第２章６．タプル型の最後の例で使った記述なのですが、内包表記と同じ記述を括弧内に書くと「要素を一つずつ生成するジェネレータオブジェクト」を返却します。
    
    これをジェネレータ式と呼びます。

'''
#ジェネレータ式

gen = (i * i for i in range(3))

for g in gen:
    print(g)    #0、1、4と順に表示
    
'''
    ジェネレータオブジェクトはイテレータの他にもリストやタプルなどに変換することができます。
    
    なお、一度別のオブジェクトに変換するとジェネレータオブジェクトの中身はクリアされてしまうので、この点には注意が必要です。

'''
#ジェネレータオブジェクトの変換

gen = (i * i for i in range(3))

#リストへの変換

print(list(gen))    #[0, 1, 4]

print(list(gen))    #[]

#タプルへの変換

gen = (i * i for i in range(3))

print(tuple(gen))   #(0, 1, 4)

'''
    さて、ここまで様々な説明をして来ましたが、最後に「sendメソッド」と「サブジェネレータ」の紹介をして本節の仕上げとします。
    
    sendメソッドはジェネレータから値を取り出す際に引数を渡すためのモノで、ジェネレータ側では"v=(yieldx)"のように記述すると引数を受け取ることができます。

    このメソッドは一度でもジェネレータから値が取り出された後でないと呼び出せません（エラーになります）。
    
    そしてサブジェネレータは「ジェネレータ内で"yieldfromiterable"と書くことで、イテラブルなオブジェクトの要素を順次返すことができる仕組み」です。
    
    これら２つについてはこれ以上深い説明はしませんので、今のところは例で動きを見て「何となく」その存在を覚えておいてもらえれば十分でしょう。

'''
#sendメソッド

def generator(step):
    val = 0
    
    prev = 0
    
    while True:
        if step is None:
            step = prev
            
        prev = prev
        
        val += step
        
        step = yield val
        
gen = generator(0)

print(next(gen))    #0

for i in range(4):
    print(gen.send(i))  #0、1、3、6と順に表示

'''

'''
#サブジェネレータ

def generator():
    yield from range(2)
    
    yield from range(4, 1, -1)
    
gen = generator()

for g in gen:
    print(g)    #0、1、4、3、2と順に表示
