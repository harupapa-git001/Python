'''
    ポリモーフィズムポリモーフィズムは日本語で多態性と訳されます。
    
    その意味をWikipediaで調べてみると以下のようにありました。
    ポリモーフィズムあるいはポリモルフィズム(Polymorphism)とは、プログラミング言語の型システムの性質を表すもので、プログラミング言語の各要素(定数、変数、式、オブジェクト、関数、メソッドなど)についてそれらが複数の型に属することを許すという性質を指す。
    
    多態性、多相性、多様性とも呼ばれる。
    ポリモーフィズムの概念をある程度理解している私にも難しくてよくわからないです。
    難しい説明よりも、簡単な例をあげて説明しましょうか。たとえば以下のコードを見てください。

    print(1 + 1)
    
    print("hello" + "python")
    
    何を今更と思われるかと思いますが、注目して欲しいのは演算子の +です。
    この +の使われかたとして「数をたす」「文字列を結合する」という2通りの使い方をされているのがわかります。
    つまりこの +は与えられる値によって、同じ「くっつける」という動きであっても挙動が微妙に違います。
    この「書き方はひとつなのだが、動き方は複数ある」というのがポリモーフィズムだと思っていただければかまいません。

    何を今更と思われるかと思いますが、注目して欲しいのは演算子の +です。この +の使われかたとして「数をたす」「文字列を結合する」という2通りの使い方をされているのがわかります。つまりこの +は与えられる値によって、同じ「くっつける」という動きであっても挙動が微妙に違います。この「書き方はひとつなのだが、動き方は複数ある」というのがポリモーフィズムだと思っていただければかまいません。

    ポリモーフィズムの「書き方はひとつなのだが、どのような動きになるかはデータに依存して複数になる」という性質を使うことで「親クラスを使うかのようにプログラムを書き、実際には子クラスが利用されている」という状況を作ります。
    
    実際にこれをコードで書いてみます。
    コードを書くにあたって重要なのは、ポリモーフィズムをどのように実現するかという方針を立てることです。
    
    それは一般的には以下のようになります。
    
    ・呼び出されるメソッドは親クラスで実装する
    ・共通した処理は親クラスに任せる
    ・子クラスは親クラスとの差分のみ実装する

    このようにすることで、子クラスのメソッドをまるで親クラスのメソッドを使うかのように呼び出し、実際は子クラスとして振る舞うということが実現できます。
    理屈をゴチャゴチャと説明しても頭が混乱しそうなので、コードで示したいと思います。
    まず最初の「呼び出されるメソッドは親クラスで実装」と「共通した処理は親クラスに任せる」を考慮した親クラスの設計をします。

'''

class Graphic:
    def __init__(self, x1, y1, x2, y2):
        self.x1 = x1
        
        self.y1 = y1
        
        self.x2 = x2
        
        self.y2 = y2
        
    def draw(self):
        print("Error")

'''
    まず、x,y座標はすべての図形で持つため、それは親に持たせています。
    そしてすべての子クラスは共通して「描画」という機能を持つので、それも親に実装します。
    
    上記でいうと print(‘Error’)になります。
    次に子クラスを実装します。親クラスのx,y座標を使いつつ、独自のdraw処理をします。

'''

rectangle = '''({}, {})

# # # # # # #

#      #

#      #

# # # # # # #

  ({}, {})'''
  
class Rectangle(Graphic):
    def draw(self):
        print(rectangle.format(self.x1, self.y1, self.x2, self.y2))
        
triangle = '''({}, {})

    #
    
   # #
   
    #    #
    
# # # # # # #

  ({}, {})'''
  
class Triangle(Graphic):
    def draw(self):
        print(triangle.format(self.x1, self.y1, self.x2, self.y2))

'''
    四角と三角をどういう数式で書くかは今回の話題ではないので、手抜きをさせてください。
    それぞれの子クラスではアスキーアートの四角、三角を座標付きで表示させています。
    実際は以下の図のように、各draw関数を実装することで、どの子クラスが利用されているかによって描画方式が変わっていると思っていただければかまいません。


    作成したコードを実際に使ってみます。まず、先ほどのアプリケーション画面を前提とします。
    どの図形を描画するか選択されているドラッグ＆ドロップが完了し、x,yはすでに取れている上記前提をおいたコードは以下のようになります。

'''

#（１）度の図形、座標とするか

graphic_type = "rectangle"

#graphic_type = "triangle"

x1, y1, x2, y2 = 1, 2, 3, 4

#（２）入力された図形に応じて小クラスのインスタンスを作成

if(graphic_type == "rectangle"):
    graphic = Rectangle(x1, y1, x2, y2)
    
elif(graphic_type == "triangle"):
    graphic = Triangle(x1, y1, x2, y2)
    
else:
    graphic = Graphic(x1, y1, x2, y2)
    
#（３）オーバーライドされた親クラスも持つメソッドの呼び出し

graphic.draw()

'''
    実際は上記のコードのgraphic_typeとx1,y1,x2,y2はマウス操作などで動的に決まります。
    重要なのはそのあとで、graphic_typeなどの値によって、「どの子クラスを使うか」は動的に決まるものの、最後の処理(3)に関してはどの子クラスであっても完全に同じ使い方をするということです。
    つまり子クラスに細かい描画の実装は任せるものの、それ以外のほぼすべては親クラスが持つ性質を使ってプログラムが実行されます。
    こうすることで、複数のクラスで似た処理を細かく大量に書くのではなく、同じ処理を複数のクラスで使い回すことができるのです。
    このあたりの話はかなり難しく、読んだだけではよくわからないと思っています。
    実際に私もそうだったのですが、ある程度自分でコードを書いてみて初めて腑に落ちることもあるので、勉強して、書いてを繰り返すのがいいのではないでしょうか。


'''
