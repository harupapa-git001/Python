'''
class MyClass:
    def __init__(self):
        self.a = "a"
        self.b = "b"
'''
#ここまででself.aは実施される直前まではインスタンスaと言うデータを持っていない
#新しくデータを作っているイメージ

class MyClass:
    def __init__(self):
        print("1: {}",format(dir(self)))
        
        self.a = "a"
        self.b = "b"
        
        print("2: {}".format(dir(self)))
        
instance = MyClass()
print("3 {}".format(dir(instance)))

'''
あるオブジェクトが持つ属性（インスタンス変数やメソッド）を確認するdir関数を使うことで、インスタンスが何を持っているか確認しています。
具体的にはコンストラクタ__init__でインスタンス変数値を代入する前後で、そのインスタンスがどのようなデータを持っているか表示しています。
そして作成し終わった後でインスタンスの中身を再度dirで確認しています。
実行結果は以下のようになります。
1:['__class__',...,'__weakref__']
2:['__class__',...,'__weakref__','a','b']
3:['__class__',...,'__weakref__','a','b']

みてもらうと分かるように全て同じインスタンスであるにもかかわらず、持っている属性にa、bが途中で追加されています。Pythonのコンストラクタは「既にあるインスタンス変数に値を入れる」と言うよりは「新しくインスタンス変数を作っている」と言えます。
'''
'''
実はこの属性の追加はコンストラクタ以外でも実行できます。例えば、先ほど作ったMyClassのインスタンスにクラスで定義されていない属性cを追加してみます。
'''
instance.c = "c"
print("4: {}".format(dir(instance)))

'''
dirで確認すると今まで孫座しなかった属性cが追加されている事がわかります。当然同じ要領でコンストラクタ以外のメソッド内でも新しくインスタンス変数を作ることはできます。メソッドでさえ新しく作る事ができます。
'''
def new_method(self):
    return "これが新しく追加されたメソッドです"

MyClass.new_method = new_method
print(instance.new_method())

print("5: {}",format(dir(instance)))

'''
    Pythonで属性はオブジェクトに「後付けできる」ということは知っておくべきだと思います。なぜならこれらのテクニックは上級レベルのプログラミングで利用されることがあるためです。ただ、意図してそのようなことをしないのであれば、コンストラクタ以外でのオブジェクトへのデータの追加は可能な限り控えるべきだと思います。インスタンスの属性があったりなかったりするとトラブルのもとですし、なによりクラスのコードだけを読んでもインスタンスがどのようなデータを持っているのかわからなくなります。インスタンスを作った時点では使わないインスタンス変数があったとしても、それは必ずコンストラクタで初期化するようにしてください。特に初心者のかたは誰が読んでも分かるコードを書くことに注意を払ってください。

'''
