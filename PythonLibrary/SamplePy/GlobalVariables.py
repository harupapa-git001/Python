'''ex1

x = 5

def add():
    #global x #global宣言
    x += 1
    
print(x)
add()
print(x)

'''

'''
    実行してみると分かりますが、実際はエラーが出てしまいます。
    上記エラーを見ると、関数の中で「変数xに値が与えられる前に参照した」というような内容となっています。
   
    結論から言いますと、プログラム1行目のxと関数内のxは別物です。
    
    そのため関数内のxを使おうとしたところ、エラーが出てしまったのです。
    関数内に存在しない1行目の変数xは「グローバルレベル」に存在する変数です。
    
    一方、関数内は「その関数のレベル」で変数などが定義されています。
    そのため、グローバルレベルの変数を関数内で使いたい場合は、関数がそれを利用できるように「global変数名」と宣言をしてあげる必要があります。
    
    具体的には#のようになります。
    
    #のようにグローバル宣言をすることで、関数の外で定義された変数xを関数の中で利用することができるようになります。
    他のプログラミング言語の経験者であればグローバルレベルから関数内の変数を見れないことを知っている人は多いのですが、Pythonにはその逆があることを知らないことが時々あるようです。

    関数内からグローバルは global宣言すれば見えるが、グローバルレベルから関数内の変数や引数は見えない。
    
    基本的にはこのルールさえ守れば問題ありません。
    ただ、実はglobal宣言しなくても関数内からグローバル変数にアクセスできる例外があります。
    
    それは「参照するだけ」の場合です。
    
    例えば以下のようなプログラムはエラーなく実行できます。


'''

'''ex2

x = 5

def print_x():
    print(x)
    
print_x()

'''

'''
    見て分かるように関数内でグローバル変数xを「参照」のみしています。
    
    これは問題ありません。
    一方、関数内でグローバル変数に「代入」のコードが存在する場合、代入する前に参照するとエラーになります。

'''

x = 5

#OK

def print_x1():
    print(x)
    
#OK

def print_x2():
    x = 3
    print(x)
    
#ERROR

def print_x3():
    y = x + 1
    
    x = 3
    
    print(x)
    
print_x1()
print_x2()
print_x3()
